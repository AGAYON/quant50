{
    "version": "1.0",
    "updated": "2025-10-29",
    "owner": "Quant50 Backend Team",
    "tasks": [
        {
            "id": "T001",
            "title": "Ingesta de datos (Alpaca ‚Üí DuckDB)",
            "description": "Crear funciones en app/services/data.py para descargar precios diarios de Alpaca Market API, almacenarlos en DuckDB (data/market.duckdb) y mantener sincronizaci√≥n incremental.",
            "depends_on": [],
            "files": [
                "app/services/data.py",
                "app/utils/config.py"
            ],
            "status": "done",
            "priority": "high",
            "test": "tests/test_data.py",
            "owner": "dev_andres",
            "tags": [
                "data",
                "alpaca",
                "duckdb",
                "ETL"
            ]
        },
        {
            "id": "T002",
            "title": "C√°lculo de features cuantitativos",
            "description": "Generar features de momentum, volatilidad, RSI, liquidez, beta, media m√≥vil, etc. en app/services/features.py a partir de los precios almacenados en DuckDB.",
            "depends_on": [
                "T001"
            ],
            "files": [
                "app/services/features.py"
            ],
            "status": "done",
            "priority": "high",
            "test": "tests/test_features.py",
            "tags": [
                "features",
                "quant",
                "pandas"
            ]
        },
        {
            "id": "T003",
            "title": "Construcci√≥n de labels (excess returns)",
            "description": "Construir labels de rendimiento excedente sobre benchmark para cada activo y periodo.",
            "depends_on": [
                "T001"
            ],
            "files": [
                "app/services/label.py"
            ],
            "status": "done",
            "priority": "medium",
            "test": "tests/test_label.py",
            "tags": [
                "labels",
                "finance",
                "returns"
            ]
        },
        {
            "id": "T004",
            "title": "Entrenamiento ML semanal (LightGBM)",
            "description": "Implementar modelo LightGBM cross-sectional. Guardar artifacts (model.pkl, scaler.pkl).",
            "depends_on": [
                "T002",
                "T003"
            ],
            "files": [
                "app/services/model.py",
                "models/"
            ],
            "status": "done",
            "priority": "high",
            "test": "tests/test_model.py",
            "tags": [
                "machine-learning",
                "lightgbm",
                "training"
            ]
        },
        {
            "id": "T005",
            "title": "Optimizaci√≥n de portafolio (cvxpy)",
            "description": "Resolver asignaci√≥n de pesos robusta con Ledoit-Wolf covariance shrinkage. 50 activos, l√≠mites sectoriales y turnover.",
            "depends_on": [
                "T004"
            ],
            "files": [
                "app/services/optimize.py"
            ],
            "status": "done",
            "priority": "high",
            "test": "tests/test_optimize.py",
            "tags": [
                "optimization",
                "cvxpy",
                "portfolio"
            ]
        },
        {
            "id": "T006",
            "title": "Ejecuci√≥n de √≥rdenes (Alpaca Paper Trading)",
            "description": "Implementar env√≠o de √≥rdenes, validaci√≥n de posiciones y logging en app/services/execute.py.",
            "depends_on": [
                "T005"
            ],
            "files": [
                "app/services/execute.py"
            ],
            "status": "done",
            "priority": "high",
            "test": "tests/test_execute.py",
            "tags": [
                "execution",
                "trading",
                "alpaca"
            ]
        },
        {
            "id": "T007",
            "title": "Reporte PDF diario",
            "description": "Generar PDF diario con KPIs: PnL, drawdown, turnover, top holdings, √≥rdenes ejecutadas.",
            "depends_on": [
                "T004",
                "T005",
                "T006"
            ],
            "files": [
                "app/services/report.py",
                "data/reports/"
            ],
            "status": "done",
            "priority": "medium",
            "test": "tests/test_report.py",
            "tags": [
                "report",
                "pdf",
                "analytics"
            ]
        },
        {
            "id": "T007B",
            "title": "Upgrade Daily Report to Desk-Ready Version",
            "description": "Enhance report.py to produce desk-ready daily report PDF with advanced metrics, visualizations, and professional presentation.",
            "depends_on": [
                "T007"
            ],
            "files": [
                "app/services/report.py",
                "app/services/report_charts.py",
                "tests/test_report.py",
                "tests/test_report_charts.py"
            ],
            "status": "done",
            "priority": "high",
            "test": "tests/test_report_charts.py",
            "tags": [
                "report",
                "visualization",
                "metrics",
                "desk-ready"
            ]
        },
        {
            "id": "T008",
            "title": "Endpoints FastAPI (/run, /report, /orders)",
            "description": "Implementar endpoints principales que orquesten las funciones de ejecuci√≥n, generaci√≥n de reportes y consulta de √≥rdenes.",
            "depends_on": [
                "T001",
                "T002",
                "T003",
                "T004",
                "T005",
                "T006",
                "T007"
            ],
            "files": [
                "app/main.py",
                "app/routes.py"
            ],
            "status": "blocked",
            "priority": "high",
            "test": "tests/test_api.py",
            "tags": [
                "api",
                "fastapi"
            ]
        },
        {
            "id": "T009",
            "title": "Automatizaci√≥n con cron / GitHub Actions",
            "description": "Programar daily_run.py (diario) y weekly_train.py (semanal) con GitHub Actions o cron local.",
            "depends_on": [
                "T004",
                "T005",
                "T006"
            ],
            "files": [
                "jobs/daily_run.py",
                "jobs/weekly_train.py",
                ".github/workflows/"
            ],
            "status": "blocked",
            "priority": "medium",
            "test": "tests/test_jobs.py",
            "tags": [
                "automation",
                "ci",
                "github-actions"
            ]
        },
        {
            "id": "T010",
            "title": "Pruebas integradas y validaci√≥n CI/CD",
            "description": "Implementar pruebas E2E que validen flujo completo desde ingesta ‚Üí modelo ‚Üí optimizaci√≥n ‚Üí ejecuci√≥n ‚Üí reporte.",
            "depends_on": [
                "T001",
                "T002",
                "T003",
                "T004",
                "T005",
                "T006",
                "T007",
                "T008",
                "T009"
            ],
            "files": [
                "tests/test_integration.py",
                ".github/workflows/ci.yml"
            ],
            "status": "blocked",
            "priority": "high",
            "tags": [
                "testing",
                "integration",
                "ci"
            ]
        },
        {
            "id": "T010",
            "title": "Pruebas integradas y validaci√≥n CI/CD",
            "description": "Implementar pruebas E2E que validen flujo completo desde ingesta ‚Üí modelo ‚Üí optimizaci√≥n ‚Üí ejecuci√≥n ‚Üí reporte.",
            "depends_on": [
                "T001",
                "T002",
                "T003",
                "T004",
                "T005",
                "T006",
                "T007",
                "T008",
                "T009"
            ],
            "files": [
                "tests/test_integration.py",
                ".github/workflows/ci.yml"
            ],
            "status": "blocked",
            "priority": "high",
            "tags": [
                "testing",
                "integration",
                "ci"
            ]
        },
        {
            "id": "T005A",
            "title": "Audit & Enforce Dynamic Selection (T005 ‚Üî T006)",
            "description": "Auditar y reforzar la selecci√≥n din√°mica de activos (m√°x 50, top-N basado en predicci√≥n), confirmar compatibilidad con ejecuci√≥n (T006), y reabrir tareas si es necesario.",
            "depends_on": [
                "T005",
                "T006"
            ],
            "files": [
                "app/services/optimize.py",
                "app/services/model.py",
                "app/services/execute.py",
                "tests/test_optimize.py",
                "tests/test_execute.py",
                ".taskmaster/tasks.json"
            ],
            "status": "done",
            "priority": "high",
            "owner": "taskmaster",
            "tags": [
                "audit",
                "selection",
                "optimization",
                "execution",
                "contracts"
            ],
            "instructions": {
                "context": [
                    "El modelo (T004) produce predicciones cross-sectional por ticker (ej. y_pred_excess).",
                    "La optimizaci√≥n (T005) debe seleccionar din√°micamente los mejores activos y asignar pesos bajo restricciones (sum=1, bounds, turnover, sector cap).",
                    "La ejecuci√≥n (T006) consume un DataFrame objetivo con columnas ['symbol','weight'] y rebalancea las posiciones en Alpaca.",
                    "La intenci√≥n de negocio: si no hay suficientes activos atractivos, el portafolio puede tener <50 posiciones; nunca forzar 50 si degrada el rendimiento esperado. M√°ximo absoluto 50."
                ],
                "goals": [
                    "Asegurar que el portafolio **selecciona din√°micamente** los mejores activos por ranking de predicci√≥n (top-N con N‚â§50).",
                    "Permitir N<50 cuando las se√±ales sean d√©biles (no llenar por obligaci√≥n).",
                    "Reemplazar autom√°ticamente los tickers cuando su ranking caiga por debajo del umbral y haya candidatos mejores.",
                    "Garantizar que el output final de T005 **suma 1.0** (capital totalmente asignado entre los seleccionados), respetando restricciones (bounds/turnover/sector).",
                    "Confirmar que T006 consume correctamente ese output y calcula deltas BUY/SELL correctos, con redondeo a **2 decimales** en cantidades.",
                    "Si hay incompatibilidades entre T005 y T006, reabrir la(s) tarea(s) y proponer/realizar correcciones acotadas."
                ],
                "ranking_policy": {
                    "source": "Predicci√≥n T004 (ej. 'y_pred_excess' o m√©trica de retorno esperado).",
                    "selection": "Ordenar descendentemente por predicci√≥n; tomar top-N con N ‚â§ 50.",
                    "min_eligibility": "Permitir filtro opcional por umbral (ej. y_pred_excess > 0). Si tras el filtro quedan 0, seleccionar el mejor subconjunto posible (>=1).",
                    "normalization": "Re-normalizar pesos al 100% entre los seleccionados antes de optimizar.",
                    "replacement": "Si un ticker sale del top-N, su peso objetivo debe caer a 0; si uno nuevo entra, se le asigna peso sujeto a restricciones."
                },
                "schema_contracts": {
                    "model_predictions": {
                        "required_columns": [
                            "timestamp",
                            "symbol",
                            "y_pred_excess"
                        ],
                        "notes": "Cross-sectional por fecha; una fila por (fecha, s√≠mbolo)."
                    },
                    "optimize_input": {
                        "required_columns": [
                            "symbol",
                            "expected_return"
                        ],
                        "mapping": "expected_return := y_pred_excess (u otra m√©trica univariada equivalente)."
                    },
                    "optimize_output": {
                        "required_columns": [
                            "symbol",
                            "weight"
                        ],
                        "constraints": [
                            "sum(weight) == 1.0 (¬±1e-6)",
                            "0 ‚â§ weight ‚â§ upper_bound",
                            "cardinalidad ‚â§ 50",
                            "turnover ‚â§ config.turnover_limit (si hay prev_weights)",
                            "sector_caps respetados si se provee mapping"
                        ]
                    },
                    "execute_input": {
                        "required_columns": [
                            "symbol",
                            "weight"
                        ],
                        "notes": "Lo consume compute_order_deltas(); las cantidades deber√°n redondearse a 2 decimales antes de enviar √≥rdenes."
                    }
                },
                "acceptance_criteria": [
                    "üîπ T005 produce un DataFrame final con ‚â§50 s√≠mbolos y 'weight' normalizado a 1.0.",
                    "üîπ Si el filtro por predicci√≥n reduce a <50, no se rellena artificialmente; se reasigna capital entre los seleccionados.",
                    "üîπ Al menos una prueba de humo confirma reemplazo: si se degrada el ranking de un s√≠mbolo previamente activo y aparece otro con mayor predicci√≥n, el nuevo portafolio objetivo **incluye** al nuevo y **excluye** al anterior.",
                    "üîπ T006: compute_order_deltas genera 'SELL' cuando el peso objetivo < peso actual; 'BUY' cuando >; y no produce √≥rdenes espurias cuando ya est√° alineado (dentro de tolerancia de redondeo).",
                    "üîπ T006: cantidades (qty) para √≥rdenes **redondeadas a 2 decimales**; no acepta qty negativas (long-only).",
                    "üîπ tests/test_optimize.py y tests/test_execute.py quedan verdes sin relajar aserciones de negocio."
                ],
                "verification_steps": [
                    "1) Revisar 'app/services/optimize.py' y confirmar que existe (o agregar) una fase expl√≠cita de selecci√≥n: ordenar por expected_return y cortar a N‚â§50.",
                    "2) Verificar que la optimizaci√≥n se ejecute sobre el subconjunto seleccionado y que el resultado se normalice a 1.0.",
                    "3) Confirmar compatibilidad columnar con T006: output final de T005 son ['symbol','weight'] (float).",
                    "4) Validar que 'app/services/execute.py' (compute_order_deltas) usa 'current_price' y 'account_value' y produce 'BUY'/'SELL' correctos, con redondeo a 2 decimales en 'delta_qty'.",
                    "5) Correr pruebas locales focalizadas: 'pytest -q -v tests/test_optimize.py tests/test_execute.py'.",
                    "6) Si se requiere ajuste, reabrir T005 y/o T006 en .taskmaster/tasks.json (status='in_progress'), aplicar cambios m√≠nimos necesarios y documentar en commit.",
                    "7) Dejar un resumen en data/reports/selection_audit_YYYYMMDD.json con: N seleccionados, top-5 s√≠mbolos por expected_return, sum(weights), flags de constraint compliance."
                ],
                "guardrails": [
                    "No introducir dependencias nuevas sin actualizar requirements.",
                    "No degradar constraints (bounds, sector caps, turnover) para pasar tests.",
                    "No cambiar contratos de T004; s√≥lo consumir sus predicciones.",
                    "No marcar T006 como 'done' sin pasar tests y sin validar deltas BUY/SELL correctos."
                ],
                "allowed_task_state_changes": [
                    "Si se detectan inconsistencias, marcar T005 o T006 como 'in_progress' y dejar comentario en commit.",
                    "Una vez verificado, devolver T005 y T006 a 'done' y dejar evidencia en selection_audit_YYYYMMDD.json."
                ],
                "commands": [
                    "pytest -q -v tests/test_optimize.py",
                    "pytest -q -v tests/test_execute.py"
                ],
                "artifacts": [
                    "data/reports/selection_audit_YYYYMMDD.json"
                ]
            }
        }
    ]
}